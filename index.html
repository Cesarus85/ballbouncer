<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>WebXR Ball Bouncer v1.3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 10;
      text-shadow: 0 0 4px #000;
    }
  </style>
</head>
<body>
  <div id="info">Tippe/Drücke, um einen Ball zu werfen</div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.163/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let controller;
    const balls  = [];
    const planes = new Map(); // XRPlane ➜ THREE.Mesh

    const gravity     = -9.81; // m/s²
    const restitution = 0.8;   // 1 = perfekt elastisch

    let prevTime = null;

    init();

    // ────────────────────────────────────────────────────────────────────────────────
    function init() {
      scene  = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      const hemi = new THREE.HemisphereLight(0xffffff, 0x666666, 1);
      scene.add(hemi);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // AR‑Button: Plane‑Detection & Passthrough
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures : [ 'hit-test', 'plane-detection' ],
        optionalFeatures : [ 'dom-overlay' ],
        domOverlay       : { root: document.body }
      }));

      // Controller ⇒ Ball erzeugen
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      renderer.setAnimationLoop(render);
      window.addEventListener('resize', onResize);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ────────────────────────────────────────────────────────────────────────────────
    //  ▄▄▄▄▄  Ball werfen
    function onSelect() {
      const radius    = 0.05;
      const geometry  = new THREE.SphereGeometry(radius, 32, 32);
      const material  = new THREE.MeshStandardMaterial({ color: 0xff5533 });
      const ball      = new THREE.Mesh(geometry, material);

      // Spawn vor der Kamera
      const xrCam = renderer.xr.getCamera(camera);
      const dir   = new THREE.Vector3(0, 0, -1).applyQuaternion(xrCam.quaternion).normalize();
      ball.position.copy(xrCam.position).add(dir.clone().multiplyScalar(0.25));

      // Velocity (3 m/s)
      ball.userData.velocity = dir.clone().multiplyScalar(3);
      ball.userData.radius   = radius;
      balls.push(ball);
      scene.add(ball);
    }

    // ────────────────────────────────────────────────────────────────────────────────
    //  ██████  Plane Handling
    function syncPlanes(frame, refSpace) {
      const { planes: xrPlanes } = frame.worldInformation ?? {};
      if (!xrPlanes) return;

      xrPlanes.forEach((xrPlane) => {
        if (!planes.has(xrPlane)) {
          const mesh = createPlaneMesh(xrPlane);
          planes.set(xrPlane, mesh);
          scene.add(mesh);
        }

        const pose = frame.getPose(xrPlane.planeSpace, refSpace);
        if (pose) {
          const mesh = planes.get(xrPlane);
          mesh.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
          mesh.quaternion.set(pose.transform.orientation.x, pose.transform.orientation.y, pose.transform.orientation.z, pose.transform.orientation.w);
        }
      });
    }

    // Plane‑Mesh: halbtransparent zum Debuggen – Größe = grobes Bounding‑Rect
    function createPlaneMesh(xrPlane) {
      // Versuche Größe abzuleiten (Fallback 2×2 m)
      let sizeX = 2, sizeZ = 2;
      if (xrPlane.polygon && xrPlane.polygon.length >= 4) {
        const xs = xrPlane.polygon.map(p => p.x);
        const zs = xrPlane.polygon.map(p => p.z);
        sizeX = Math.max(...xs) - Math.min(...xs);
        sizeZ = Math.max(...zs) - Math.min(...zs);
      }
      const geometry = new THREE.PlaneGeometry(sizeX, sizeZ);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      
      // Speichere XRPlane-Referenz für korrekte Normalenberechnung
      mesh.userData.xrPlane = xrPlane;
      return mesh;
    }

    // ────────────────────────────────────────────────────────────────────────────────
    //  ▀▀▀▀▀▀  Physik‑Simulation (verbessert)
    function simulate(delta) {
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];

        // Gravitation ➜ v = v + g·Δt
        ball.userData.velocity.y += gravity * delta;

        // Bewegung mit Kollisionsprüfung
        let remainingTime = delta;
        let currentPos = ball.position.clone();
        let currentVel = ball.userData.velocity.clone();
        
        // Maximal 3 Bounces pro Frame um Stuck-Loops zu vermeiden
        for (let bounce = 0; bounce < 3 && remainingTime > 0.001; bounce++) {
          const nextPos = currentPos.clone().addScaledVector(currentVel, remainingTime);
          let nearestCollision = null;
          let nearestT = 1;

          // Finde nächste Kollision mit allen Ebenen
          planes.forEach(mesh => {
            const xrPlane = mesh.userData.xrPlane;
            if (!xrPlane) return;

            // Korrekte Normale aus XRPlane-Orientation (Z-Achse der Ebene)
            const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(mesh.quaternion).normalize();
            const planePt = mesh.position;

            // Distanzen zur Ebene (mit Kugelradius)
            const distA = new THREE.Vector3().subVectors(currentPos, planePt).dot(normal) - ball.userData.radius;
            const distB = new THREE.Vector3().subVectors(nextPos, planePt).dot(normal) - ball.userData.radius;

            // Kollision wenn Distanz das Vorzeichen wechselt
            if (distA > 0 && distB <= 0) {
              // Berechne Kollisionszeitpunkt
              const t = Math.max(0, Math.min(1, distA / (distA - distB)));
              if (t < nearestT) {
                nearestT = t;
                nearestCollision = { mesh, normal, planePt };
              }
            }
          });

          if (nearestCollision) {
            // Bewege zur Kollisionsposition
            const collisionPos = currentPos.clone().addScaledVector(currentVel, remainingTime * nearestT);
            
            // Reflektiere Geschwindigkeit
            const { normal } = nearestCollision;
            const vDotN = currentVel.dot(normal);
            if (vDotN < 0) { // Nur reflektieren wenn sich dem Plane nähert
              currentVel.addScaledVector(normal, -2 * vDotN * restitution);
            }

            // Position leicht oberhalb der Oberfläche setzen
            currentPos.copy(collisionPos).addScaledVector(normal, ball.userData.radius + 0.001);
            
            // Verbleibende Zeit reduzieren
            remainingTime *= (1 - nearestT);
          } else {
            // Keine Kollision, normale Bewegung
            currentPos.copy(nextPos);
            remainingTime = 0;
          }
        }

        // Endgültige Position übernehmen
        ball.position.copy(currentPos);
        ball.userData.velocity.copy(currentVel);

        // Lebensdauer‑Cleanup
        if (ball.position.y < -5) {
          scene.remove(ball);
          balls.splice(i, 1);
        }
      }
    }

    // ────────────────────────────────────────────────────────────────────────────────
    function render(time, frame) {
      const delta = prevTime === null ? 0 : (time - prevTime) / 1000;
      prevTime = time;

      if (frame) {
        const refSpace = renderer.xr.getReferenceSpace();
        syncPlanes(frame, refSpace);
      }

      simulate(delta);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>