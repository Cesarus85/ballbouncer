<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <title>WebXR AR Bouncer – Plane Detection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay { position:fixed; inset:0; display:flex; align-items:flex-start; justify-content:center; pointer-events:none; }
    #panel { pointer-events:auto; margin:10px; padding:10px 12px; background:rgba(0,0,0,.45); color:#fff; font:14px/1.35 system-ui,sans-serif; border-radius:8px; }
    #btnFire, #btnScan { margin-top:6px; padding:8px 12px; border:0; border-radius:6px; background:#fff; color:#000; font-weight:600; cursor:pointer; }
    #btnScan { margin-left:6px; }
    #status { opacity:.85; font-size:12px; margin-top:6px; }
    #legend { font-size:12px; opacity:.8; margin-top:6px; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="panel">
      <b>AR Bouncer (Planes):</b> Tippe, um Bälle zu feuern. Erkennt echte Flächen (sofern unterstützt).<br/>
      <button id="btnFire">Ball feuern</button>
      <!-- NEU: manueller Trigger für Room Capture -->
      <button id="btnScan" title="Raumerfassung starten (Quest 3)">Raum erfassen</button>
      <div id="status">Warte auf AR…</div>
      <div id="legend">Grün = horizontal (Boden/Tisch), Blau = vertikal (Wand)</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    let renderer, scene, camera, xrSession, refSpace;
    let lastTS = null;

    // Flags für Room Capture
    let triedRoomCapture = false;
    let planesSeen = false;

    // Fallback-Raum (wenn keine Planes vorhanden)
    const fallbackRoom = {
      center: new THREE.Vector3(),
      size: new THREE.Vector3(4, 2.5, 4),
      floorY: 0,
      boxHelper: null,
      active: false
    };

    // Physik
    const balls = [];
    const GRAVITY = -9.81;
    const RESTITUTION = 0.75;
    const LINEAR_DAMPING = 0.01;

    // Plane-Store
    const planeSet = new Map();

    init();

    function init() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.xr.enabled = true;
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.01, 50);

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
      const dl = new THREE.DirectionalLight(0xffffff, 0.7); dl.position.set(1, 2, 1); scene.add(dl);

      makeFallbackBox();

      const arBtn = ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay','plane-detection','depth-sensing'],
        domOverlay: { root: document.body },
        depthSensing: {
          usagePreference: ['cpu-optimized','gpu-optimized'],
          dataFormatPreference: ['luminance-alpha','float32']
        }
      });
      document.body.appendChild(arBtn);

      renderer.xr.addEventListener('sessionstart', onSessionStart);
      renderer.xr.addEventListener('sessionend', onSessionEnd);

      document.getElementById('btnFire').addEventListener('click', () => spawnBallFromCamera(4.5));
      window.addEventListener('pointerdown', () => spawnBallFromCamera(4.5));
      window.addEventListener('resize', onResize);

      // NEU: Manueller Button für Room Capture
      const btnScan = document.getElementById('btnScan');
      btnScan.addEventListener('click', async () => {
        const s = renderer.xr.getSession?.();
        if (!s) return;
        if (!triedRoomCapture && s?.initiateRoomCapture) {
          triedRoomCapture = true;
          try {
            document.getElementById('status').textContent = 'Raumerfassung wird gestartet…';
            await s.initiateRoomCapture();
          } catch (e) {
            console.warn('initiateRoomCapture() error:', e);
            document.getElementById('status').textContent = 'Raumerfassung nicht möglich oder abgebrochen.';
          }
        }
      });

      renderer.setAnimationLoop(onXRFrame);
    }

    function onResize() {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    function onSessionStart() {
      xrSession = renderer.xr.getSession();
      xrSession.requestReferenceSpace('local').then(rs => { refSpace = rs; });
      document.getElementById('status').textContent = 'AR aktiv. Suche nach Flächen…';

      // NEU: Session-Reset der Flags
      triedRoomCapture = false;
      planesSeen = false;

      // NEU: Auto-Trigger nach 4s, falls noch keine Planes sichtbar
      setTimeout(async () => {
        const s = renderer.xr.getSession?.();
        if (!planesSeen && !triedRoomCapture && s?.initiateRoomCapture) {
          triedRoomCapture = true;
          try {
            document.getElementById('status').textContent = 'Keine Flächen erkannt – starte Raumerfassung…';
            await s.initiateRoomCapture();
          } catch (e) {
            console.warn('auto initiateRoomCapture() error:', e);
            document.getElementById('status').textContent = 'Raumerfassung nicht möglich oder abgebrochen.';
          }
        }
      }, 4000);
    }

    function onSessionEnd() {
      xrSession = null;
      planeSet.forEach(p => scene.remove(p.mesh));
      planeSet.clear();
      fallbackRoom.active = false;
      triedRoomCapture = false;
      planesSeen = false;
      document.getElementById('status').textContent = 'Warte auf AR…';
    }

    function makeFallbackBox() {
      const g = new THREE.EdgesGeometry(new THREE.BoxGeometry(fallbackRoom.size.x, fallbackRoom.size.y, fallbackRoom.size.z));
      const m = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent:true, opacity:0.4 });
      fallbackRoom.boxHelper = new THREE.LineSegments(g, m);
      fallbackRoom.boxHelper.visible = false;
      scene.add(fallbackRoom.boxHelper);
    }

    function ensureFallbackAtCam() {
      if (fallbackRoom.active) return;
      const xrCam = renderer.xr.getCamera(camera);
      const origin = new THREE.Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      fallbackRoom.floorY = origin.y - 1.4;
      fallbackRoom.center.copy(origin);
      fallbackRoom.center.z -= 1.0;
      fallbackRoom.center.y = fallbackRoom.floorY + fallbackRoom.size.y / 2;
      fallbackRoom.boxHelper.position.copy(fallbackRoom.center);
      fallbackRoom.boxHelper.visible = true;
      fallbackRoom.active = true;
      document.getElementById('status').textContent = 'Fallback-Raum aktiv (keine echten Flächen erkannt).';
    }

    function spawnBallFromCamera(speed=4.5) {
      if (!renderer.xr.isPresenting) return;
      const xrCam = renderer.xr.getCamera(camera);
      const origin = new THREE.Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(xrCam.quaternion).normalize();

      const radius = 0.06;
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 24, 20),
        new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.4 })
      );
      mesh.position.copy(origin).addScaledVector(forward, 0.25).y += 0.05;
      scene.add(mesh);

      balls.push({ mesh, radius, vel: forward.multiplyScalar(speed).add(new THREE.Vector3(0, 0.5, 0)) });
    }

    function upsertPlaneMesh(xrPlane, frame) {
      const planePose = frame.getPose(xrPlane.planeSpace, refSpace);
      if (!planePose) return;

      const poly = xrPlane.polygon || xrPlane.vertices || [];
      if (!poly || poly.length < 3) return;

      const mat4 = new THREE.Matrix4().fromArray(planePose.transform.matrix);
      const worldPts = poly.map(dp => new THREE.Vector3(dp.x, dp.y, dp.z).applyMatrix4(mat4));

      const n = new THREE.Vector3(0,1,0).applyMatrix4(new THREE.Matrix4().extractRotation(mat4)).normalize();
      const p0 = worldPts[0].clone();

      let entry = planeSet.get(xrPlane);
      const isHorizontal = Math.abs(n.y) > 0.707;
      const color = isHorizontal ? 0x00ff88 : 0x3399ff;

      if (!entry) {
        const geom = new THREE.BufferGeometry();
        const verts = triangulateConvex(worldPts);
        geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        geom.computeVertexNormals();

        const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.18, side:THREE.DoubleSide });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.renderOrder = 999;
        scene.add(mesh);

        entry = { mesh, normal: n.clone(), worldPoint: p0.clone() };
        planeSet.set(xrPlane, entry);
      } else {
        const verts = triangulateConvex(worldPts);
        entry.mesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        entry.mesh.geometry.computeVertexNormals();
        entry.mesh.material.color.setHex(color);
        entry.normal.copy(n);
        entry.worldPoint.copy(p0);
        entry.mesh.visible = true;
      }
    }

    function triangulateConvex(points) {
      const out = [];
      for (let i=1; i<points.length-1; i++) {
        const a = points[0], b = points[i], c = points[i+1];
        out.push(a.x,a.y,a.z, b.x,b.y,b.z, c.x,c.y,c.z);
      }
      return new Float32Array(out);
    }

    function simulate(dt) {
      const hasPlanes = planeSet.size > 0;

      for (let i=balls.length-1; i>=0; i--) {
        const b = balls[i];
        const p = b.mesh.position;
        const v = b.vel;

        v.y += GRAVITY * dt;
        p.addScaledVector(v, dt);
        v.multiplyScalar(1 - LINEAR_DAMPING);

        let collided = false;

        if (hasPlanes) {
          planeSet.forEach(({normal:n, worldPoint:p0}) => {
            const dist = n.dot(new THREE.Vector3().subVectors(p, p0));
            if (dist < b.radius && n.dot(v) < 0) {
              const push = b.radius - dist;
              p.addScaledVector(n, push);
              const vn = n.clone().multiplyScalar(v.dot(n));
              const vt = v.clone().sub(vn);
              const vRef = vt.addScaledVector(vn, -RESTITUTION);
              v.copy(vRef);
              collided = true;
            }
          });
        }

        if (!hasPlanes && fallbackRoom.active) {
          const min = new THREE.Vector3(
            fallbackRoom.center.x - fallbackRoom.size.x/2,
            fallbackRoom.floorY,
            fallbackRoom.center.z - fallbackRoom.size.z/2
          );
          const max = new THREE.Vector3(
            fallbackRoom.center.x + fallbackRoom.size.x/2,
            fallbackRoom.floorY + fallbackRoom.size.y,
            fallbackRoom.center.z + fallbackRoom.size.z/2
          );
          if (p.x - b.radius < min.x) { p.x = min.x + b.radius; v.x = -v.x*RESTITUTION; collided = true; }
          if (p.x + b.radius > max.x) { p.x = max.x - b.radius; v.x = -v.x*RESTITUTION; collided = true; }
          if (p.y - b.radius < min.y) { p.y = min.y + b.radius; v.y = -v.y*RESTITUTION; collided = true; }
          if (p.y + b.radius > max.y) { p.y = max.y - b.radius; v.y = -v.y*RESTITUTION; collided = true; }
          if (p.z - b.radius < min.z) { p.z = min.z + b.radius; v.z = -v.z*RESTITUTION; collided = true; }
          if (p.z + b.radius > max.z) { p.z = max.z - b.radius; v.z = -v.z*RESTITUTION; collided = true; }
        }

        if (!hasPlanes && fallbackRoom.active) {
          if (Math.abs(p.y - (fallbackRoom.floorY + b.radius)) < 0.01 && v.lengthSq() < 0.02*0.02) {
            scene.remove(b.mesh); balls.splice(i,1);
          }
        } else if (collided && v.lengthSq() < 0.02*0.02) {
          scene.remove(b.mesh); balls.splice(i,1);
        }
      }
    }

    function onXRFrame(t, frame) {
      if (!frame) { renderer.render(scene, camera); return; }
      if (!refSpace) { renderer.render(scene, camera); return; }

      const session = renderer.xr.getSession();

      let planes = frame.worldInformation?.detectedPlanes || session?.worldInformation?.detectedPlanes;
      if (planes && planes.size !== undefined) {
        if (planes.size > 0) {
          planesSeen = true;                      // NEU: merken, dass echte Planes da sind
          fallbackRoom.boxHelper.visible = false;
          fallbackRoom.active = false;
          document.getElementById('status').textContent = 'Echte Flächen erkannt ✔';
        } else {
          ensureFallbackAtCam();
        }
        planes.forEach(xrPlane => upsertPlaneMesh(xrPlane, frame));
      } else {
        ensureFallbackAtCam();
      }

      if (lastTS === null) lastTS = t;
      const dt = Math.min((t - lastTS)/1000, 0.032);
      lastTS = t;

      simulate(dt);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
